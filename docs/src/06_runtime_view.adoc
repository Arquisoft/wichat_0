ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View


ifdef::arc42help[]
[role="arc42help"]
****
.Contents
The runtime view describes concrete behavior and interactions of the system’s building blocks in form of scenarios from the following areas:

* important use cases or features: how do building blocks execute them?
* interactions at critical external interfaces: how do building blocks cooperate with users and neighboring systems?
* operation and administration: launch, start-up, stop
* error and exception scenarios

Remark: The main criterion for the choice of possible scenarios (sequences, workflows) is their *architectural relevance*. It is *not* important to describe a large number of scenarios. You should rather document a representative selection.

.Motivation
You should understand how (instances of) building blocks of your system perform their job and communicate at runtime.
You will mainly capture scenarios in your documentation to communicate your architecture to stakeholders that are less willing or able to read and understand the static models (building block view, deployment view).

.Form
There are many notations for describing scenarios, e.g.

* numbered list of steps (in natural language)
* activity diagrams or flow charts
* sequence diagrams
* BPMN or EPCs (event process chains)
* state machines
* ...


.Further Information

See https://docs.arc42.org/section-6/[Runtime View] in the arc42 documentation.

****
endif::arc42help[]

=== Abstract general state diagram

* General usage, the user arrives to the application, creates an account or logs in, goes through the menu settings and plays.
The state diagram shows the relation of the different situations of the app.

[mermaid,"State diagram",png]
[*] --> Create Account
Create Account --> LogIn
LogIn --> LogOut
LogIn --> Menu
LogOut --> LogIn
LogOut --> Create Account
Menu --> Play
Play --> Menu
Menu --> [*]
Play --> [*]

* _<insert runtime diagram or textual description of the scenario>_
* _<insert description of the notable aspects of the interactions between the
building block instances depicted in this diagram.>_



=== Login of a user

* Login, the app shows the login interface, where the user is asked for the username and password, and the possibility to create an account.

When logging, the app does a login request to the authentication service through the GatewayService, which redirects the user to the identity provider, which handles the authentication by checking the registered users.
If the login is succesfully, the app shows the different options of the game. In case the login isn’t succesfully, a warning message is shown.

[plantuml,"Sequence diagram",png]
----
actor User
participant WebApp
participant GatewayService 
participant AuthService 
database DB as "MongoDB"
WebApp -> WebApp: Display Login View
User -> WebApp: Choose avatar
WebApp -> GatewayService: Request login
GatewayService -> AuthService: Redirect request
AuthService -> DB: Fetch users
DB -> AuthService: Registered users
AuthService -> GatewayService: Authorise request
GatewayService -> WebApp: Return session 
----

=== Game

* Game transitions and process behind the user interface. Introducing the GameService, QuestionService, LLMService, WikiDataService.

When playing, the user interface interacts with the distribution facade GatewayService, in charge of hiding the back-end services and business and persistance layers.

[plantuml,"Sequence diagram",png]
----
actor User
participant WebApp
participant GatewayService 
participant QuestionService 
participant LLMService 
participant LLM  
participant WikiDataService 
participant WikiData
participant GameService  
database DB as "MongoDB"
User -> WebApp: Start Game
WebApp -> GatewayService: Request question
GatewayService -> GatewayService: Request login
GatewayService -> QuestionService: Redirect request
QuestionService -> LLMService: Redirect request
LLMService -> LLM: Redirect request
LLM -> LLMService: Return question
LLMService -> QuestionService: Return question
QuestionService -> GatewayService: Return question
GatewayService -> WebApp: Return question
WebApp -> User: Displays question and options
User -> WebApp: Choose answer
WebApp -> WebApp: Verifies answer
WebApp -> User: Show result and score
User -> WebApp: Finish game
WebApp -> User: Show final score
WebApp -> GatewayService: Saves game dataç
GatewayService -> GameService: Redirects request
GameService -> DB: Store result
----

=== History of a user

* History of a user including stats of the games played.

When the user enters the history view, it is displayed the games played alongside contextual information, featuring:
- Number of games played
- Time scores of the best games
- Relation of correct / incorrect answers

[plantuml,"Sequence diagram",png]
----
actor User
participant WebApp
participant GatewayService 
participant GameService 
database DB as "MongoDB"
WebApp -> WebApp: Display history option
User -> WebApp: Choose history
WebApp -> GatewayService: Request request
GatewayService -> GameService: Redirect request
GameService -> DB: Fetch history
DB -> GameService: Returns the history of the user
GameService -> GatewayService: Returns the response
GatewayService -> WebApp: Returns the response
WebApp -> User: Displays the history accordingly
----
